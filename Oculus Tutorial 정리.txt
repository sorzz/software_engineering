OVRCamerRig와 TrackedAlias만 사용할것임.
CameraRig가 Tracked의 위치로 이동함.

cameraRig에 LinkedAliasAssoCol- 추가하고
각각 위치에 오브젝트 Anchor 넣어줌..



텔레포트 정리

ObjectPointer.Curved를 TrackAlias와 같은 위치에 둔다.

ObjectPointer의 FollowSource는 여기로 순간이동을 한다는 뜻인것같다.

그래서 거기다가 LeftcontrollerAlias를 추가했음.

Activation Action에는 활성화 됐을때의 객체를 넣는건데 그래서
새로운 오브젝트에 스크립트 넣고 그 옵젝을 할당해줄거임.

그래서 TeleporterActivation이라는 빈객체만들고 스크립트 넣어줌. 그리고 컨트롤러에다가는 L Touch(기기)를 선택. 하고 Touch에는 THumstick(버튼)을 선택해줌.

글고 그 위에 Activated이런 칸에는 활성화가 된다면 뭐가 실행될지 지정해주는거임. 하지만이번에는 외부에서 관리할것이기 때문에 그냥 참거짓만 판별하면 됨 얘는..

다시 Pointer로 돌아와서 Activation Action에다가 Teleporter객체를 넣어줌. 그럼 이제 teleporter가 true라면 pointer가 활성화가 된다. 이런 느낌이지~

But 포인터가 손에 나타남 ㅋㅋㅋ 도착지에 나타나야지!옛끼!~~~ 수정해보자잉~~
이유는 머냐면 포인터가 어디에 닿았을때 활성화?되는건데 지금 바로 손에 닿아버려서 그럼. 그럼 어째야해? 손이랑은 만나도 아무렇지 않게만들어줘야징..ㅇㅇ

그럼 이제 어쩌냐면 왼손오른손 선택해서 Layer에서 ignore Raycast로 설정!
포인터==레이저 이런 느낌 인가봄.

근데 지금 바닥은 collider가 없어서 바닥에 인식이안됨. 바닥에는 cube로 collider 깔아주자~

Activation 한거랑 마찬가지로 그건 손가락 데면 포인터 활성화! 였는데 이제 거기로 가고싶르면 선택!을 해줘야하니까 TeleporterSelection이라는 것도 만들어줌 touch대신 button으로만 스크립트 변경해주면됨 ㅇㅇ

다시 pointer로 들어와서 selection 오브젝트를 Selection Action에 넣어줌! 이제 얘가 true값이면 몸을 움직여야하잖아? 그 기능응ㄹ 아래쪽 Selected칸에 넣어주면되는거야

근데 그 칸에 뭘 넣어줄거냐~ 기존 asset에 있는 Teleporter.instant를 사용할것임.

Teleporter.instant안에 있는 Target이란 실제로 이동하게 될 객체.
이곳에다가 TrackedAlias->PlayAreaAlias 이놈을 넣어줄거임. 근데 이 PlayerAlias는 OVRCameraRig와 연결되어있으니까 결국 OVR이놈도 움직인다보면 되겠찌.

Offset에는 headsetAlias를 넣어줌. 머리 높이 만큼 들려있어야하니까?ㅇㅇ 머 쨋든

그러고 다시 pointer로 와서 Selected액션에 Teleport.instant 추가하고 이놈의 Teleport메소드를 선택해줌. 즉 버튼이 눌리면 selected가 true니까 teleport메소드가 실행됨.










본격 바위로 창문깨기!!!!!!!!!!!!! 와장창 꺄악 털썩..

VRTK에 존재하는!
primary grap.secondary swap 이라는놈을~! (처음으로 잡으면 그랩이고 두번째로 잡으면 swap,교체가 된다는 뜻!)
Props에 덩그러니 넣어줌. 이 안에다가 돌을 넣으려는 심산인듯.

ㅇㅇ grap의 디폴트 메쉬 비활성화 해주고, 메쉬안에 stone01넣어줌. 
이때 stone의 transform은 다 리셋 해버리고 grab의 scale을 조절함
그리고 또 stone에 box collider 추가해서 잡을 수 있게 해줌.

이제 손부분! TrackedAlias > L/R Controller Alias에 각각 막대기같은 interactor 넣어줌.
그리고 interactor > Collider > Example 이부분이 인식되는 부분임. 손 크기에맞게 조절해줌.그리고 Box Collider 빼고 다 지워벌임. 눈에 보일 필요 없는 애니까!

interactor 속성에서 Grab Action을 채워줘야함! 또  Grab Action 이라는 새로운 오브젝트 만들자. 그리고 이놈이 이제 잡는 버튼을 인식해야하는데 우리 아까 만들었자나 OVR Input BUtton이라는 스크립트! 그놈으로 Grab Action_L/_R 이렇게 두개 만들어서 각각 넣어주고. 버튼 설정해쥼 ㅇㅇ

그담에 interactor에서 Grabbed랑 Ungrabbed 설정해줄건뎅 +로 엘리먼트 추가하고
각각 왼손 오른손을 의미하는 custom hand를 집어넣어줌. 글고 setActive메소드 설정ㄱㄱ

항상 정 중앙으로 물건이 잡히는데 그거 말고 내가 잡는대로 잡형ㅆ으면 좋겠음..
그건 피벗이 가운데에 있어서 그럼. 바꾸는법
primary grap.secondary swap > Facade > GrabLogic > FollowAction > GrabOffset 을 
Precision 을 선택하면 잡는 위치가 잡히게 됨.


물체를 던져벌여보자~~
OVRCameraRig > HandAnchor 에다가 Average Velocity Estimator를추가해줌.
Source에다가는 어떤 물체를 기준으로 속력을 측정할건지 넣어줌.
각자 본인들 넣어주고, Relative To에다가는 CenterEyeAnchor 넣어줌. 눈을 기준으로 손이 얼마나 움직였는지 파악해보겠따 이런거진.

그리고 OVRcamerRig기본에서 Linked 그속성에 Left Controller Velocity에다가
Left Hand Anchor 넣어주고, 오른쪽도 마찬가지로 ㅇㅇ

그리고 각 손에달린 Interactor에 Velocity Tracker란에는 각 L/RControllerAlias를 넣어줌.


이제 문이 깨질차례임. 깨지는 동작을 하기위해 script 작성.
OnCollisionEnter에다가 바위라면~ audiosource.Play() 해줌.
그리고 창문에다가 AudioSource 컴포넌트 추가해서 창 깨지는 소리 넣어줌.


제약 조건!
- 잡을 수 있는 놈들은 다 ignore laycast 설정해줌.
- Teleporter Rule 이라는 객체 생성해서 anyLayerRule 추가
이건 뭐냐면 설정한 레이어에서만 어떠한 처리를 할 수 있는 조건?같은거임
각 바닥 콜라이더에 Floor레이어 설정해주고, Rule컴포넌트에도 Floor로 설정. 
그러고 나서 Teleporter.intant & Pointer > Target Validity에 Rule적용해줌.











[ 열 쇠 로 문 열 기 대 작 전 ! ]

스냅존이라는 것을 하는 것이다 ~~ 우선 열쇠구멍을 추가 해 주자잉

문 열릴 때 같이 열릴거니까 뜬금에다가 추가하지말고 Door의 하위에 넣어줌.

그리고 interactable snapzone이라는것을 keyhole의 자식에 추가..
글고 snapZone > SnapDest > Highlight > Mesh> Default mesh 비활성화 해주고.
여기에다가 Key prefab을 넣어줌.
그다음 PointerDefaultValid라는것을 Key에다가 넣어줌. 그럼 키가 초래짐.
그럼 스냅존에 오브젝트가 다가가면 저게 초록색으로 뜰거임

글고 ActivationArea는 이제 뭐가 다가왔는지 파악해주는 영역임. 크기 조절 해줌.

InteractableSnapZone의 Snapped 이벤트를 설정해주자꾸낭. 여기서 문 열리는 애니메이션 설정해줄거임. +로 추가해서 Door_single해주고 SetTrigger로 Open넣어줌.

그리고 이제 손으로 잡을 열쇠를 바닥에 둘거임! 자 직접 해보자! 위에 정리한거 보면서!!
ㅇㅇ 손으로 잡을 수 있고 문도 이렇게만 하면 열림!!
근데 내가 꽂은 키가 어디로 갔을꽈? 알아서 그 스냅존에 뿅 박혀버리는듯 이위치는 DestinationLocation 조절해서 정해줌.

키를 주웠을 때 키가잡혀있는게 어색행 이걸 방향을 좀 바꿔주고 시포
그러면 그 Primary Grab > Facade에 찾아보면 GrabLogic 부분으로 이동해봐
그다음 또 FollowAction 에서 Grab Offset을 Orientation으로 !! (지정값)이라는 뜻그리고
마지막에 있는 속성중 OrientationHandles > GenericOri- 여기서 방향 돌려줌...

그리고 문의 Mesh Collider에 Convex가 체크되어있는데 이거 체크되어있으면 문이 열려도 가로막혀지게 됨 그래서 해제 해주어야한다잉.




*GameScene 프리팹을 Unpack해준담에 다 수정하고 나중에 걍다시 Prefabs 폴더에 넣어주면 편함!

[서랍 열기!]

사물을 주어진 범위내에서 움직이게 하는것을 해볼테야..

directionalJointDrive를 Chest of drawers안에다가 넣어줌.
2번째 서랍에만적용ㄹ을 해보겠다.

2번의 transform 정보를 복붙해서 Joint에붙여줌. 이 Joint 안에 있는 Primary_Grab > DefaultMesh 삭제or비활성화하고 서랍을 Meshes에 넣기.


노란선이 보일텐데 이거만큼 움직인다는 뜻.
Target Value값을 조절해줘야함. 축도 바꿔줄수있고 ㅇㅇ

서랍이 너무 많이 나오거나 들어가면 이상하자나 Limit를 걸어줄테야..

근데 limit걸면 뽑는건 맞춰지는데 들어가는건 계속 다 들어감.

해결법 > JointContainer > Joint 에서 Connected Anchor

그리고 TargetValue는 0으로 두고시작하면
닫힌 상태로 시작 ㅇㅇ 1로 하면 열리는쪽으로만 증가하는 뭐 그런..?

MoveToTargetValue는 관성? 같은거 있는거라 체크 해제. 근데 그래도 질금질금 움직임. 이건 DriveSpeed를 아예 0으로 해버리면 됨!


글고 이제 서랍도 잡혔다고인식할 수 있으려면 Collider설정해줘야함. Drawer2에 Collider추가


[캐비닛 문열기!]

이건 방향이 아닌 회전이므로 Directional말고 RotationalT~
이 Rotation넣을때 전에는 계속일단 넣고 Transform 복붙해줬자나 그러지말고 걍
spind안에 넣었다가 빼면 위치 맞춰짐.
spind전체를 처리할게 아니라 문만 처리할것이므로 Spind의 자식으로 넣고 또 메쉬 없애고 tuere넣어줌.

그리고 Rotation에서 DriveAxis랑 DriveLimit조절하셈


근데 이제 열쇠가 꽂혀있어야만 문이 열렸으면 좋겠음 ~~!! 그럼 조건을 좀 걸어줘야게쮜..

일단 열쇠인식하는거부터 맨들어보장.
tuere안에다가 snapzone넣어주고 ㅇㅇ


이제 Snapped 이벤트에다가 뭘해주냐가 문제지영. 엘리먼트 추가해주고. Rotational 자체를 넣어줌. MoveToTargetValue가뭐나면 슬라이드바를 가지고 직접값을 조절해서 움직임을 가지게 하는거임. 이걸 체크하면 슬라이드로만 움직이고 손으로는 안움직임! (아닌디 아까움직였자나ㅜ 근데 이건 안영ㄹ리긴 해.) 쨋든 그래서 이 체크를 비활성화해주면 문이 열린다는거지 손으로.


+ 열쇠만 인식하게 하는 법~~!! 지금은 막 돌맹이 갖다놔도 열리닌께.;; 텔레포트룰 처럼 하면 됨. SnapZoneRule이라고 만들었음~
이걸 SnapZone의 SnapValidity에 넣어줌.




